<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://clearsky.dev/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Javascript in space</title></head><body><header id=banner><h2><a href=https://clearsky.dev/>ClearSky</a></h2><nav><ul></ul></nav></header><main id=content><article><header id=post-header><h1>Javascript in space</h1><div><time>May 23, 2020</time></div></header><p>From a young age, I have always been fascinated by space. Most of all, the <a href=https://en.wikipedia.org/wiki/Apollo_program>Apollo program</a> has always been a source of inspiration for me. But unlike most kids, I would not picture myself in a spacesuit. I would picture myself in mission control. I was always more interested in the technology. Fixing an electrical problem in a spacecraft hundreds of thousands of kilometers a way by understanding everything about it and pushing the right buttons.</p><p>Although I became a developer and never did anything related to space professionally, the interest remained. So when SpaceX offered an <a href=http://iss-sim.spacex.com/>online simulator</a> where you have to dock the dragon spacecraft to the international spacestation, ofcourse I took a look. And not being a gamer or astronaut, ofcourse I crashed that dragon right into the ISS on the first few tries (sorry, NASA). So what does a developer do when a task is too hard? He gets his computer to do it.</p><p>Flying a spacecraft is a great task for a computer. The apollo spacecraft had an autopilot as part of its guidance computer. It was a great piece of engineering, developed at MIT. They <a href=https://www.wired.com/2015/10/margaret-hamilton-nasa-apollo/>basically invented ‘software’ as they were going</a>. The real SpaceX dragon capsule also has an autopilot, which has already docked it to the ISS countless times.</p><p>After having read so much about these systems, I thought it would be a fun challenge to write an autopilot for this simulator. Let&rsquo;s dive right in!</p><h2 id=space-101>Space 101</h2><p>Let’s start with some terminology. Flying a spacecraft is a bit different from driving a car. Instead of only turning left and right, you can <strong>turn in 6 directions</strong>.</p><p><figure><a href=/blog/javascript-in-space/rollpitchyaw.jpeg><picture><source media="(max-width: 376px)" srcset=/blog/javascript-in-space/rollpitchyaw_hu69ad81764a186682ecf4e4f96f0d6ded_82708_500x0_resize_q75_h2_box.webp><source media="(max-width: 992px)" srcset=/blog/javascript-in-space/rollpitchyaw_hu69ad81764a186682ecf4e4f96f0d6ded_82708_800x0_resize_q75_h2_box.webp><source media="(max-width: 1400px)" srcset=/blog/javascript-in-space/rollpitchyaw_hu69ad81764a186682ecf4e4f96f0d6ded_82708_1200x0_resize_q75_h2_box.webp><source media="(min-width: 1600px)" srcset=/blog/javascript-in-space/rollpitchyaw_hu69ad81764a186682ecf4e4f96f0d6ded_82708_1500x0_resize_q75_h2_box.webp><img alt=Rotation title=Rotation src=rollpitchyaw.jpeg class=img-fluid></picture></a><figcaption></figcaption></figure></p><p>But that is just <strong>rotation</strong>. We won’t get any closer to the ISS by rotating around our own axes. For that, we need <strong>translation</strong>. The spacecraft has small rockets pointing different directions to rotate. These are also used to fly in any direction without needing to rotate in the direction it wants to fly in. In other words: you don’t have to fly in the direction that the nose of the spacecraft is pointing.</p><p><figure><a href=/blog/javascript-in-space/xyz.jpeg><picture><source media="(max-width: 376px)" srcset=/blog/javascript-in-space/xyz_hudff856d8ca53f2e52480fdb206f6a577_92575_500x0_resize_q75_h2_box.webp><source media="(max-width: 992px)" srcset=/blog/javascript-in-space/xyz_hudff856d8ca53f2e52480fdb206f6a577_92575_800x0_resize_q75_h2_box.webp><source media="(max-width: 1400px)" srcset=/blog/javascript-in-space/xyz_hudff856d8ca53f2e52480fdb206f6a577_92575_1200x0_resize_q75_h2_box.webp><source media="(min-width: 1600px)" srcset=/blog/javascript-in-space/xyz_hudff856d8ca53f2e52480fdb206f6a577_92575_1500x0_resize_q75_h2_box.webp><img alt=translation title=translation src=xyz.jpeg class=img-fluid></picture></a><figcaption></figcaption></figure></p><p>All these things can be done independently. So you can rotate without moving, and move without rotating. You can also do it at the same time, although that can be more challenging.</p><p>One other major difference between space and life on earth: <strong>when you start moving, you’ll keep on moving</strong>. So when i press the ‘yaw right’ button, the spacecraft will start rotating right, and keep going until i press the ‘yaw left’ button to neutralize the movement.</p><h2 id=setup>Setup</h2><p>First challenge: how do we write code that interacts with SpaceX’s simulator, which is essentially a website? I chose a solution that is simple and easy to setup: a browser plugin that lets me execute javascript code inside websites. I’m using <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en">tampermonkey</a> which works in chrome. Other browsers have similar plugins.</p><h2 id=systematic-docking>Systematic docking.</h2><p>Now that we have a grip on the simulator, let’s think about the different steps that are needed to dock. After a couple of tries, I came to the conclusion that the easiest way is to line up in front of the port first, and then you only have to move forward! Here’s the 5 step plan to a succesful dock:</p><p><figure><a href=/blog/javascript-in-space/steps.png><picture><source media="(max-width: 376px)" srcset=/blog/javascript-in-space/steps_hu32669e3b43263f0c4c03e66772ee67af_362442_500x0_resize_q75_h2_box_3.webp><source media="(max-width: 992px)" srcset=/blog/javascript-in-space/steps_hu32669e3b43263f0c4c03e66772ee67af_362442_800x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/blog/javascript-in-space/steps_hu32669e3b43263f0c4c03e66772ee67af_362442_1200x0_resize_q75_h2_box_3.webp><source media="(min-width: 1600px)" srcset=/blog/javascript-in-space/steps_hu32669e3b43263f0c4c03e66772ee67af_362442_1500x0_resize_q75_h2_box_3.webp><img alt="The master plan" title="The master plan" src=steps.png class=img-fluid></picture></a><figcaption></figcaption></figure></p><ol><li><strong>Orient</strong>: First, we want the spacecraft to point the right way (roll pitch and yaw). This makes navigating a lot easier.</li><li><strong>Translate</strong>: Then, we want to make sure that the spacecraft is exactly in front of the docking port.</li><li><strong>Approach</strong>: Next, we will approach the docking port. This can be done at relatively high speed, and without any course correction. I configured the hold distance to be about 20 meters.</li><li><strong>Translate</strong>: at the hold point, we will probably have a small translation error. We need to correct those before moving on. This is the same as step 2, but with greater precision.</li><li><strong>Dock</strong>: Lastly, we move into the docking port at a very slow speed, correcting translation while flying</li></ol><h2 id=the-autopilot-loop>The autopilot loop</h2><p>On a high level, the autopilot does 3 things over and over:</p><ol><li>Gather data about the current state of the spacecraft</li><li>Decide where the spacecraft should go</li><li>Take the necessary actions to get closer to that goal.</li></ol><p>That looks like this when you talk javascript:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fly</span>(<span style=color:#a6e22e>state</span>) { 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>updateSensors</span>(<span style=color:#a6e22e>state</span>)  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>actions</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>runProgram</span>(<span style=color:#a6e22e>state</span>) 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>executeActions</span>(<span style=color:#a6e22e>actions</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It does these things in a loop. You would think that everything happens very fast when rockets are involved. In practice, the absence of atmosphere makes movements of spacecraft much more predictable and easier to manage. Also as I mentioned, the best way to dock is very slowly! <a href=https://www.nasa.gov/mission_pages/shuttle/flyout/flyfeature_shuttlecomputers.html>The spaceshuttle docking procedure ran 25 times per second</a>. My autopilot only runs once per second.</p><h2 id=gather-data>Gather data</h2><p>The simulator displays a number of measurements that will help us decide what to do. So we need to get all those values. The great thing is that these numbers are all present in html nodes (thanks, SpaceX programmers!). For instance, we can get the value of the pitch error as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span>parseFloat(document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#34;#pitch .error&#34;</span>).<span style=color:#a6e22e>textContent</span>)
</span></span></code></pre></div><p>The complete list of values that I fetch from the html can be seen in <code>updateSensors</code>. All these variables are written to an object called <code>state</code> which contains all data that the autopilot uses.</p><h2 id=decision-time>Decision time</h2><p>To make the decisions, I defined 5 different “programs”. Each program is responsible for achieving a step in the 5-step plan that I described. It also detects when it has achieved its goal and activates the next program. Only 1 program runs at any time.</p><p>Discussing each program would make this post too long and boring. Lets just take a look at the first program. If you want to know more about the other programs, have a look at the code :-)</p><p>The first program is called <strong>orient</strong>. It deals with the 3 rotational axis: roll, pitch and yaw. Its goal is to point the spacecraft the right way. The simulator shows the “error” for each axis: the difference between the current orientation of the spacecraft and the orientation that is needed to dock.
So orient’s goal in more technical terms is: bring the pitch, yaw and roll errors to within -0.2 and +0.2.</p><p>The simulator controls have a button to put them in “precision mode”. This means the effect of pressing a button will be smaller, allowing you to make more precise corrections. The first thing the program does is check if precision mode is on, and id not, queues an action to enable it.</p><p>Next, it will determine if there are actions needed in any of the 3 axis (roll, pitch, yaw). Since the logic is the same for each axis, i do this in a for loop.</p><p>There are 4 situations that require the rotate program to take action. Lets take the roll axis as an example</p><ol><li>The spacecraft is not rolling, and is angled to the left. We need to start rolling right</li><li>The spacecraft is rolling right, and oriented correctly. We need to stop rolling</li><li>The spacecraft is not rolling, and is angled to the right. We need to start rolling left</li><li>The spacecraft is rolling left, and is oriented correctly. We need to stop rolling</li></ol><p>The last thing the program needs to do is to see if it has reached its goal. If all the errors are within the margin it updates the state to set the current program to “translate”</p><p>The other programs do basically the same thing. Fire some thrusters to move in the right direction, wait for the goal to be reached, fire thrusters in the opposite direction to stop moving.</p><h2 id=take-action>Take action</h2><p>When we have decided which way to fly, we need a way to let the simulator do what we want. I implemented this by simulating a ‘click’ event on the appropriate button like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span>document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#960050;background-color:#1e0010>‘</span><span style=color:#a6e22e>yaw</span><span style=color:#f92672>-</span><span style=color:#a6e22e>right</span><span style=color:#f92672>-</span><span style=color:#a6e22e>button</span><span style=color:#960050;background-color:#1e0010>’</span>).<span style=color:#a6e22e>click</span>();
</span></span></code></pre></div><h2 id=lets-fly>Lets fly!</h2><p>So about 300 lines of code gets us safely docked… in the simulator. An autopilot in a real spacecraft would probably have more safety features and checks. If it detects something is off, it will retreat to a safe postion. One thing that real flight computers also deal with: what happens when a thruster stops working? You can probably keep steering by using the remaining thrusters in a smart way.
So this 300 line script is not even close to a real autopilot. But it was certainly fun to create!
If you want to try it, head over to my github repo <a href=https://github.com/richmans/autopilot>https://github.com/richmans/autopilot</a> and follow the installation instructions. If you have any ideas or improvements, PR’s are very welcome :-)</p><p>Thanks to Sven for the awesome illustrations!</p></article></main><footer id=footer></footer></body></html>